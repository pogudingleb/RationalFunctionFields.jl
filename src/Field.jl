"""
    RationalFunctionField

A subfield of the field of rational functions over the rationals.

## Example

```jldoctest
using Nemo
using StructuralIdentifiability: RationalFunctionField

R, (x, y, z) = QQ["x", "y", "z"]

# Constructs a subfield generated by x / y, y / z
rff = RationalFunctionField([x // y, y // z])

# Constructs a subfield generated by y / x, 1 / x, z / y
rff = RationalFunctionField([[x, y, R(1)], [y, z]])
```
"""
mutable struct RationalFunctionField{T}
    dennums::Vector{Vector{T}}
    mqs::IdealMQS{T}
    mqs_membership::IdealMQS{T}

    # cached transcendence-related information
    trbasis_probability::Float64
    trbasis::Vector{Generic.FracFieldElem{T}}
    # trancendence basis of the ambient rational function field over the given one
    trbasis_over::Vector{T}

    function RationalFunctionField(polys::Vector{T}) where {T}
        RationalFunctionField(polys .// one(parent(first(polys))))
    end

    function RationalFunctionField(fractions::Vector{Generic.FracFieldElem{T}}) where {T}
        RationalFunctionField(fractions_to_dennums(fractions))
    end

    function RationalFunctionField(dennums::Vector{Vector{T}}) where {T}
        @assert !isempty(dennums)
        F = new{T}(
            dennums,
            IdealMQS(dennums),
            IdealMQS(dennums),
            0,
            Vector{Generic.FracFieldElem{T}}(),
            Vector{T}(),
        )
        update_trbasis_info!(F, 0.9999)
        return F
    end
end

# ------------------------------------------------------------------------------

function trivial(F::RationalFunctionField)
    return isempty(F.dennums)
end

function isconstant(F::RationalFunctionField)
    return all(map(d -> all(map(p -> total_degree(p) == 0, d)), F.dennums))
end

function poly_ring(F::RationalFunctionField)
    return parent(first(first(F.dennums)))
end

function generators(F::RationalFunctionField)
    return dennums_to_fractions(F.dennums)
end

function Base.zero(F::RationalFunctionField)
    return zero(poly_ring(F)) // one(poly_ring(F))
end

function Base.one(F::RationalFunctionField)
    return one(poly_ring(F)) // one(poly_ring(F))
end

# ------------------------------------------------------------------------------

function update_trbasis_info!(F::RationalFunctionField, p::Float64)
    F.trbasis_probability = p
    fgens = generators(F)
    base_vars = gens(poly_ring(F))
    if isempty(base_vars)
        return
    end
    if isempty(fgens)
        return
    end
    maxdeg = maximum(map(total_degree_frac, fgens), init = 1) - 1
    # degree of the polynomial whose nonvanishing will be needed for correct result
    D = max(10, Int(ceil(maxdeg * length(base_vars) / (1 - p))))
    eval_point = [Nemo.QQ(rand(1:D)) for x in base_vars]

    J = jacobian(fgens, eval_point)
    pivots, _ = select_pivots(Nemo.rref(J)[2])
    _, nonpivots = select_pivots(Nemo.rref(transpose(J))[2])

    old_trbasis = F.trbasis
    F.trbasis = [fgens[i] for i in pivots]
    F.trbasis_over = [base_vars[i] for i in nonpivots]
    @assert length(F.trbasis) + length(F.trbasis_over) == length(base_vars)

    if old_trbasis != F.trbasis
        F.mqs_membership =
            IdealMQS(vcat(F.dennums, [[x, one(poly_ring(F))] for x in F.trbasis_over]))
    end
end

# ------------------------------------------------------------------------------

function _check_algebraicity(trbasis, ratfuncs, sampling_range)
    if isempty(ratfuncs)
        return Bool[]
    end
    if isempty(trbasis)
        return map(f -> total_degree_frac(f) == 0, ratfuncs)
    end
    polyring = parent(numerator(first(trbasis)))
    field = base_ring(polyring)

    while true
        eval_point = [field(rand(1:sampling_range)) for _ in gens(polyring)]

        J = jacobian(vcat(trbasis, zero(first(trbasis))), eval_point)
        rank = LinearAlgebra.rank(J)
        if rank < length(trbasis)
            continue
        end

        result = Bool[]
        for f in ratfuncs
            f = parent_ring_change(f, polyring)
            for (j, x) in enumerate(gens(polyring))
                J[j, end] = evaluate(derivative(f, x), eval_point)
            end
            push!(result, LinearAlgebra.rank(J) == rank)
        end
        return result
    end
end

# ------------------------------------------------------------------------------

"""
    check_algebraicity(field, ratfuncs, p)

Checks whether given rational function `ratfuncs` are algebraic over the field `field`
The result is correct with probability at least `p`

Inputs:
- `F` - a rational function field
- `ratfuncs` - a list of lists of rational functions.
- `p` real number from (0, 1)

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function is algebraic over the `field`
"""
function check_algebraicity(F::RationalFunctionField, ratfuncs, p)
    if isempty(ratfuncs)
        return Bool[]
    end
    if p > F.trbasis_probability
        update_trbasis_info!(F, p)
    end
    trbasis = F.trbasis
    maxdeg = maximum(map(total_degree_frac, vcat(ratfuncs, trbasis))) - 1

    # Here the story for correctness is tricky. Consider the cases when the answer may be wrong
    # - if the element is algebraic, then the only way the function would return incorrect result
    #   is if the trbasis was incorrect
    # - if the element is transcendental, the only way to return incorrect result would be
    #   to have the determinant vanishing regardless of the correctness of the transcendence basis

    # degree of the polynomial whose nonvanishing will be needed for correct result
    D = max(
        10,
        Int(ceil(maxdeg * (length(trbasis) + 1) * (length(ratfuncs) + 1) / (1 - p))),
    )

    return _check_algebraicity(trbasis, ratfuncs, D)
end

# ------------------------------------------------------------------------------

"""
    check_algebraicity_modp(field, ratfuncs, prime)

Checks whether given rational function `ratfuncs` are algebraic over the field `field`
via randomization modulo the given `prime`

Inputs:
- `F` - a rational function field
- `ratfuncs` - a list of lists of rational functions.
- `prime` a prime number

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
  the modular test concludes that the i-th function is algebraic over the `field`
  (no mathematical guarantees)
"""
function check_algebraicity_modp(F::RationalFunctionField, ratfuncs, prime = 2^31 - 1)
    if isempty(ratfuncs)
        return Bool[]
    end
    finite_field = Nemo.Native.GF(prime)
    trbasis_modp = [_reduce_mod_p(f, prime) for f in F.trbasis]
    ratfuncs_modp = [_reduce_mod_p(f, prime) for f in ratfuncs]

    return _check_algebraicity(trbasis_modp, ratfuncs_modp, prime - 1)
end

# ------------------------------------------------------------------------------

# checks containment under assumption that rat_funcs are algebraic over the field
function field_contains_algebraic_mod_p(field, rat_funcs, prime)
    ff = Nemo.Native.GF(prime)
    mqs_generators = field.mqs_membership
    reduce_mod_p!(mqs_generators, ff)

    param_ring = ParamPunPam.parent_params(mqs_generators)
    point = ParamPunPam.distinct_nonzero_points(ff, nvars(param_ring))

    gens_specialized = ParamPunPam.specialize_mod_p(mqs_generators, point)
    ratfuncs_mqs_specialized = specialize_fracs_to_mqs(mqs_generators, rat_funcs, point)
    @assert parent(first(gens_specialized)) == parent(first(ratfuncs_mqs_specialized))
    gb = groebner(gens_specialized)
    return map(iszero, normalform(gb, ratfuncs_mqs_specialized))
end

"""
    field_contains_mod_p(field, rat_funcs, prime)

Checks whether given rational functions belong to a given field of rational
functions over integers via a reduction modulo a prime (thus, no guarantees)
Inputs:
- `field` - a rational function field
- `ratfuncs` - a list of rational functions
- `prime` - a prime number

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to ``field`` (indicated by the mod-p test)
"""

@timeit _to function field_contains_mod_p(
    field::RationalFunctionField{T},
    ratfuncs::Vector{Generic.FracFieldElem{T}},
    prime = 2^31 - 1,
) where {T}
    if isempty(ratfuncs)
        return Bool[]
    end

    algebraicity = check_algebraicity_modp(field, ratfuncs, prime)
    if !any(algebraicity)
        return algebraicity
    end
    ratfuncs_algebraic = ratfuncs[algebraicity]

    return merge_results(
        algebraicity,
        field_contains_algebraic_mod_p(field, ratfuncs_algebraic, prime),
    )
end

function field_contains_mod_p(
    field::RationalFunctionField{T},
    ratfuncs::Vector{Vector{T}},
    prime = 2^31 - 1,
) where {T}
    return field_contains_mod_p(field, dennums_to_fractions(ratfuncs), prime)
end

function issubfield_mod_p(
    F::RationalFunctionField{T},
    E::RationalFunctionField{T},
    prime = 2^31 - 1,
) where {T}
    if !all(check_algebraicity_modp(E, generators(F), prime))
        return false
    end
    return all(field_contains_algebraic_mod_p(E, generators(F), prime))
end

# ------------------------------------------------------------------------------

# checks containment under assumption that rat_funcs are algebraic over the field
function field_contains_algebraic(field, ratfuncs, prob_threshold)
    start_time = time_ns()
    @debug "Estimating the sampling bound"

    # uses Theorem 3.3 from https://arxiv.org/pdf/2111.00991.pdf
    # the comments below use the notation from the theorem
    ratfuncs = [
        (iszero(f) || (total_degree(numerator(f)) > total_degree(denominator(f)))) ? f :
        1 // f for f in ratfuncs
    ]
    denoms = map(denominator, ratfuncs)
    ring = parent(numerator(first(ratfuncs)))
    den_lcm = reduce(lcm, field.mqs.dens_to_sat_orig, init = reduce(lcm, denoms))
    @debug "Common lcm is $den_lcm"

    # this is deg(g) + 1
    degree = total_degree(den_lcm) + 1
    # computing maximum of deg(f) for different f's to be tested
    for (i, f) in enumerate(ratfuncs)
        extra_degree = total_degree(den_lcm) - total_degree(denominator(f))
        degree = max(degree, extra_degree + total_degree(numerator(f)))
    end
    # computing maximum of deg(f_i) for the generators of the field
    for (i, plist) in enumerate(field.dennums)
        extra_degree = total_degree(den_lcm) - total_degree(field.mqs.dens_qq[i])
        degree = max(degree, extra_degree + maximum(total_degree, plist))
    end
    @debug "\tBound for the degrees is $degree"

    total_vars = foldl(
        union,
        map(plist -> foldl(union, map(poly -> Set(vars(poly)), plist)), field.dennums),
    )
    @debug "\tThe total number of variables in $(length(total_vars))"
    sampling_bound = BigInt(
        3 *
        BigInt(degree)^(length(total_vars) + 3) *
        (length(ratfuncs)) *
        ceil(1 / (1 - prob_threshold)),
    )

    @debug "\tSampling from $(-sampling_bound) to $(sampling_bound)"
    mqs = field.mqs_membership
    param_ring = ParamPunPam.parent_params(mqs)
    point = map(v -> Nemo.QQ(rand((-sampling_bound):sampling_bound)), gens(param_ring))
    mqs_specialized = specialize(mqs, point)
    @debug "Computing Groebner basis ($(length(mqs_specialized)) equations)"
    mqs_ratfuncs = specialize_fracs_to_mqs(mqs, ratfuncs, point)
    @assert parent(first(mqs_specialized)) == parent(first(mqs_ratfuncs))
    @debug "Starting the groebner basis computation"
    gb = groebner(mqs_specialized)
    @debug "Computing GB in $((time_ns() - start_time) / 1e9) seconds"
    start_time = time_ns()
    res = map(iszero, normalform(gb, mqs_ratfuncs))
    @debug "Normal forms computed in $((time_ns() - start_time) / 1e9) seconds"
    return res
end

"""
    field_contains(field, ratfuncs, prob_threshold)

Checks whether given rational function field `field` contains given rational
functions `ratfuncs`. The result is correct with probability at least `prob_threshold`

Inputs:
- `field` - a rational function field
- `ratfuncs` - a list of rational functions
- `prob_threshold` real number from (0, 1)

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to `field`
"""
@timeit _to function field_contains(
    field::RationalFunctionField{T},
    ratfuncs::Vector{Generic.FracFieldElem{T}},
    prob_threshold,
) where {T}
    if isempty(ratfuncs)
        return Bool[]
    end

    half_p = 1 - (1 - prob_threshold) / 100

    start_time = time_ns()
    algebraicity = check_algebraicity(field, ratfuncs, half_p)
    ratfuncs_algebraic = ratfuncs[algebraicity]
    @debug "Algebraicity checked in $((time_ns() - start_time)/1e9) seconds"
    if isempty(ratfuncs_algebraic)
        return algebraicity
    end

    half_p = 1 - (1 - prob_threshold) * 99.0 / 100
    return merge_results(
        algebraicity,
        field_contains_algebraic(field, ratfuncs_algebraic, half_p),
    )
end

function field_contains(
    field::RationalFunctionField{T},
    ratfuncs::Vector{Vector{T}},
    prob_threshold,
) where {T}
    return field_contains(field, dennums_to_fractions(ratfuncs), prob_threshold)
end

function field_contains(
    field::RationalFunctionField{T},
    polys::Vector{T},
    prob_threshold,
) where {T}
    id = one(parent(first(polys)))
    return field_contains(field, [p // id for p in polys], prob_threshold)
end

# ------------------------------------------------------------------------------

function issubfield(
    F::RationalFunctionField{T},
    E::RationalFunctionField{T},
    prob_threshold,
) where {T}
    half_p = 1 - (1 - prob_threshold) / 2
    if !all(check_algebraicity(E, generators(F), half_p))
        return false
    end
    return all(field_contains_algebraic(E, generators(F), prob_threshold))
end

function fields_equal(
    F::RationalFunctionField{T},
    E::RationalFunctionField{T},
    prob_threshold,
) where {T}
    new_p = 1 - (1 - prob_threshold) / 2
    return issubfield(F, E, new_p) && issubfield(E, F, new_p)
end

