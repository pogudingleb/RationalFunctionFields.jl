# RationalFunctionFields

[![Build Status](https://github.com/pogudingleb/RationalFunctionFields.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/pogudingleb/RationalFunctionFields.jl/actions/workflows/CI.yml?query=branch%3Amain)

`RationalFunctionFields.jl` is a Julia package for computing with subfield of the rational function field $\mathbb{Q}(x_1, \ldots, x_n)$.
The functionality includes algorithms for checking algebraicity and membership, field equality and inclusion, and for finding a simplified set of generators.
Most of the algorithms are Monte-Carlo randomized and allow user to provide a bound on the probability of error.

## How to install

The package can be installed from the Julia registry by
```julia
using Pkg
Pkg.add("RationalFunctionFields")
```

## Basic usage

The package can be loaded with 
```julia
using RationalFunctionFields
```

For our introductory example, we consider a subfield of $\mathbb{Q}(x, y)$ generated by three polynomials $x^2 + y^2$, $x^3 + y^3$, and $x^4 + y^4$.
We use [`Nemo`](https://github.com/Nemocas/Nemo.jl) for handling polynomials and polynomial ring, so we first create the corresponding polynomial ring.

```julia
using Nemo
R, (x, y) = polynomial_ring(QQ, ["x", "y"])
```

Now we can create the our field as follows

```julia
F = RationalFunctionField([x^2 + y^2, x^3 + y^3, x^4 + y^4])
```

Function `field_contains` can be used to check if given elements belong to the field with the given probability of correctness (99% in the call below):

```julia
containment = field_contains(F, [x, x + y], 0.99)
```

After this call, `containment` will be an array of two Booleans `false` ($x$ does not belong to the field since it is not symmetric) and `true` ($x + y$ turn out to be an element of the field).
Now one may wonder, how $x + y$ can be written in terms of the generators of the field. 
This can be done using `constructive_membership` function to which we provide `tag_names` --- the variables names to be used for the generators $x^2 + y^2$, $x^3 + y^3$, and $x^4 + y^4$.

```julia
expr, tag_dict = constructive_membership(F, [x + y], tag_names = ["s2", "s3", "s4"])
```

Here `expr` will be an array containing a single element: the expression of $x + y$ in terms of the generators:

```
(-1//4*s2^5 + 1//4*s2^3*s4 + 1//2*s2^2*s3^2 + 1//2*s2*s4^2 - s3^2*s4)//(s2*s3*s4 - s3^3)
```

The dictionary `tag_dict` will give the correspondence between the variables `s2`, `s3`, and `s4` used in the above formula:

```
Dict{QQMPolyRingElem, AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}} with 3 entries:
  s3 => x^3 + y^3
  s2 => x^2 + y^2
  s4 => x^4 + y^4
```

At this point, we may suspect that the field is in fact equal to the field of symmetric functions (generated by $x + y$ and $xy$). 
This can be checked using the `fields_equal` function (again, the result will be correct with probability at least 99% since we provide `0.99` as the last argument):

```julia
fields_equal(F, RationalFunctionField([x + y, x * y]), 0.99)
```

Or, the idea to check this equality could have passed by: no problem! We can use function `simplified_generating_set` which tries to find "a simpler" set of generators for the same field:

```julia
simplified_generating_set(F)
```

And, voil√†, it returns $x + y$ and $xy$:

```
2-element Vector{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}}:
 x + y
 x*y
```

## Contacts

The package is maintained by Alexander Demin ([asdemin_2@edu.hse.ru](asdemin_2@edu.hse.ru)) and Gleb Pogudin ([gleb.pogudin@polytechnique.edu](mailto:gleb.pogudin@polytechnique.edu)).
