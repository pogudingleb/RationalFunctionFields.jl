import Pkg; Pkg.activate(joinpath(@__DIR__, "..", "env"))
using StructuralIdentifiability, RationalFunctionFields, Nemo, Dates

# get `benchmarks`
include(joinpath(dirname(dirname(pathof(StructuralIdentifiability))), "benchmarking", "benchmarks.jl"))

systems = []

for name in keys(benchmarks)
    push!(systems, Dict(:name => name))
end

# https://discourse.julialang.org/t/how-to-get-username/93023/2
function username()
    varnames = ["LOGNAME", "USER", "LNAME",  "USERNAME"]
    for varname in varnames haskey(ENV, varname) && return ENV[varname] end
end

function get_file_meta_header(comment)
"""$(comment^3) This file is machine-generated.
$(comment^3) Date: $(Dates.format(now(), "Y-m-d H:M:S"))
$(comment^3) Author: $(username())
$(comment^3) Generated by this command: $(join(vcat("julia", @__FILE__, ARGS), " "))

"""
end

templates = Dict(
    "populate_data_1" => 
Dict(
"" =>
"""
import Pkg; Pkg.activate(joinpath(@__DIR__, "..", "..", "env"))
using StructuralIdentifiability, RationalFunctionFields, Nemo

# 0. Define parameters.
name = :{{name}}
with_states = {{with_states}}

# 1. Get the definition of `benchmarks`.
include(joinpath(dirname(dirname(pathof(StructuralIdentifiability))), \"benchmarking\", \"benchmarks.jl\"))
ode = benchmarks[name][:ode]
    
# 2. Some preprocessing. May take time.
funcs = StructuralIdentifiability.initial_identifiable_functions(ode, prob_threshold=0.99, with_states=with_states)[1]

# 3. Produce the original generating set. Careful when printing, may be huge.
initial_generating_set = RationalFunctionFields.dennums_to_fractions(funcs);

# 4. Compute a simpler generating set using our algorithm.
simple_funcs = simplified_generating_set(RationalFunctionFields.RationalFunctionField(funcs))

println(simple_funcs)"""
),
)

method_ext = Dict(
    "populate_data_1" => Dict("" => ".jl"),
)
filename_map = Dict(
    "populate_data_1" => "run",
)

prefix = "../data-1"

normname(name) = replace(string(name), "." => "_", " " => "_")

function foo()
    !isdir(joinpath(@__DIR__, prefix)) && mkdir(joinpath(@__DIR__, prefix))
    for system in systems
        system_name = system[:name]
        for method in collect(templates)
            method_name, method_scripts = method
            !isdir(joinpath(@__DIR__, prefix, normname(system_name))) && mkdir(joinpath(@__DIR__, prefix, normname(system_name)))
            subs = (
                "{{name}}"  => normname(system_name),
                "{{with_states}}"  => "false",
            )
            for (script_name, script_template) in method_scripts
                content = replace(script_template, subs...)
                @assert !occursin("{{", content)
                content = string(get_file_meta_header("#"), content)
                file_name = string(filename_map[method_name], method_ext[method_name][script_name])
                file_path = joinpath(@__DIR__, prefix, normname(system_name), file_name)
                open(file_path, "w") do io
                    println(io, content)
                    println("Written $file_name to $file_path")
                end
            end
        end
    end
end

println(ARGS)
foo()


