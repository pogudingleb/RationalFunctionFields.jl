import Pkg; Pkg.activate(joinpath(@__DIR__, "..", "env"))
using StructuralIdentifiability, RationalFunctionFields, Nemo, Dates

include("i4-boku.jl")
include("param-2.jl")
include("moments3.jl")

# get `benchmarks`
include(joinpath(dirname(dirname(pathof(StructuralIdentifiability))), "benchmarking", "benchmarks.jl"))

skipped = ["NFkB", "Covid2", "Akt", "TumorPillis", "TumorHu", "LeukaemiaLeon2021", "MAPK_5out_bis", "cLV2", "QWWC", "Ovarian_follicle"]

# https://discourse.julialang.org/t/how-to-get-username/93023/2
function username()
    varnames = ["LOGNAME", "USER", "LNAME",  "USERNAME"]
    for varname in varnames haskey(ENV, varname) && return ENV[varname] end
end

function get_file_meta_header(comment)
"""$(comment^3) This file is machine-generated.
$(comment^3) Date: $(Dates.format(now(), "Y-m-d H:M:S"))
$(comment^3) Author: $(username())
$(comment^3) Generated by this command: $(join(vcat("julia", @__FILE__, ARGS), " "))

"""
end

function sys_from_funcs(funcs)
    rff = RationalFunctionFields.RationalFunctionField(funcs);
    sys = RationalFunctionFields.fractionfree_generators_raw(rff.mqs)
    sys, y, x = (sys.sys, sys.indets, sys.params)
    sys = filter(!iszero, sys)
    sys, y, x
end

function sys_from_ode(ode; with_states=false)
    ode = ode[:ode]
    funcs = StructuralIdentifiability.initial_identifiable_functions(ode, prob_threshold=0.99, with_states=with_states)[1]
    sys_from_funcs(funcs)
end

templates = Dict(
    "f4-direct" => 
"""
using Groebner, Nemo
include(joinpath(@__DIR__, "..", "parser.jl"))
include(joinpath(@__DIR__, "..", "utils.jl"))
    
P, _ = polynomial_ring(Nemo.QQ, [{{:x}}])
R, _ = polynomial_ring(fraction_field(P), [{{:y}}])

big_ring, ({{y}}, {{x}}) = polynomial_ring(QQ, [{{:y}}, {{:x}}])

system = map(s -> parse_poly(big_ring, s), [{{sys_str}}])

varmap = Dict((({{y}}) .=> gens(R))..., (({{x}}) .=> gens(P))...)
system = map(f -> eval_at_dict(f, varmap), system)
    
@time gb = groebner(system, ordering=DegRevLex())

for f in gb println(f) end
""",

    "f4-flat" => 
"""
using Groebner, Nemo
include(joinpath(@__DIR__, "..", "parser.jl"))

R, ({{y}}, {{x}}) = polynomial_ring(QQ, [{{:y}}, {{:x}}])

system = map(s -> parse_poly(R, s), [{{sys_str}}])

@time gb = groebner(system, ordering=DegRevLex({{y}})*DegRevLex({{x}}))

for f in gb println(f) end
""",

    "paramgb" =>
"""
using ParamPunPam, Nemo
include(joinpath(@__DIR__, "..", "parser.jl"))
include(joinpath(@__DIR__, "..", "utils.jl"))
    
P, _ = polynomial_ring(Nemo.QQ, [{{:x}}])
R, _ = polynomial_ring(fraction_field(P), [{{:y}}])

big_ring, ({{y}}, {{x}}) = polynomial_ring(QQ, [{{:y}}, {{:x}}])

system = map(s -> parse_poly(big_ring, s), [{{sys_str}}])

varmap = Dict((({{y}}) .=> gens(R))..., (({{x}}) .=> gens(P))...)
system = map(f -> eval_at_dict(f, varmap), system)
    
@time gb = paramgb(system, ordering=DegRevLex());

for f in gb println(f) end
""",
    
    "ffmodstd" =>
"""
LIB "ffmodstd.lib";

ring R=(0, {{x}}),({{y}}),dp;
ideal I = {{sys}};

int t=timer;
ffmodStd(I);
print(timer-t);

quit;
""",

    "slimgb" =>
"""
ring R=(0, {{x}}),({{y}}),dp;
ideal I = {{sys}};

int t=timer;
slimgb(I);
print(timer-t);

quit;
""",
)

method_ext = Dict("f4-direct" => ".jl", "f4-flat" => ".jl", "paramgb" => ".jl", "ffmodstd" => ".sing", "slimgb" => ".sing")

comment = Dict(
    ".jl"   => "#",
    ".sing" => "//",
    ".mpl"  => "#"
)

function main()
    if isempty(ARGS)
        want_systems = ["Bilirubin", "EAIHRD", "SLIQR", "Lincomp2", "Pharm", "MAPK_5out", "Akt"]
    else
        want_systems = ARGS
    end
    
    systems = []
    for name in collect(keys(benchmarks))
        if any(s -> occursin(s, string(name)), skipped)
            @error "Skipping $name"
            continue
        end
        if !any(s -> occursin(s, string(name)), want_systems)
            continue
        end
        try
            push!(systems, Dict(:name => name, :system => sys_from_ode(benchmarks[name])))
        catch e end
    end
    
    push!(systems, Dict(:name => :moments3, :system => sys_from_funcs(moments3())))
    push!(systems, Dict(:name => :i4_boku, :system => i4_boku()))
    push!(systems, Dict(:name => :param2, :system => param2()))
        
    for system in systems
        name, sys = system[:name], system[:system]
        @info "Working on $name"
        sys, y, x = sys
        subs = (
            "{{x}}"  => join(map(string, x), ","),
            "{{y}}"  => join(map(string, y), ","),
            "{{:x}}" => join(map(f -> string(":", f), x), ","),
            "{{:y}}" => join(map(f -> string(":", f), y), ","),
            "{{sys}}" => join(map(string, sys), ","),
            "{{sys_str}}" => join(map(f -> "\""*string(f)*"\"", sys), ","),
        )
        for method in collect(keys(templates))
            content = replace(templates[method], subs...)
            @assert !occursin("{{", content)
            content = string(get_file_meta_header(comment[method_ext[method]]), content)
            file_name = string(name, method_ext[method])
            file_path = joinpath(@__DIR__, method, file_name)
            open(file_path, "w") do io
                println(io, content)
                println("Written $file_name to $file_path")
            end
        end
    end
end

main()
